---
title: "si_analysis"
output: html_document
---
Analysis for Scalar Implicature tablet task (Rose Schneider, Michael Frank). This study is an adaptation of the Scalar Implicature storybook game (Horowitz & Frank, 2015), and is a follow-up to Horowitz, Schneider, & Frank (in prep) to test the relationship between developmental changes in scalar implicature computatio, quantifier comprehension, and processing time. Participants saw 30 test trials with 3 book covers, each containing 4 familiar objects (e.g., book one: 4 cats, book two: 2 cats and 2 birds, book three: 4 dogs). Participants heard an audio prompt ("some/none/all of the pictures are cats"), and made their selection based on that prompt. Response times were recorded from the onset of the target word (i.e., "cats"). The planned sample is 96 3-5-year-olds, with 24 participants in each 6-month age bin. 

# Setup

Load required libraries

```{r}
library(knitr)
opts_chunk$set(cache=TRUE, message=FALSE, warning=FALSE)
```

Preliminaries

```{r}
rm(list=ls())
library(ggplot2)
library(reshape)
# library(plyr)
library(lme4)
library(dplyr)
library(stringr)
library(tidyr)
# library(markdown)
library(directlabels)
library(magrittr)
# library(bootstrap)
library(RCurl)
library(langcog)
# library(RColorBrewer)
library(diptest)
library(gridExtra)
library(RWiener)
theme_set(theme_bw())
```

# Data loading and cleaning

Load data. 

```{r}
df <- read.csv("cdm_tablet_csv.csv")
```

Clean up data for analysis. 

```{R}
df %<>%
  mutate(age = as.numeric(age))%>%
  mutate(resp = factor(correct, levels=c("Y","N"), labels=c("upper","lower")), 
         q = rt/1000)%>%
  filter(selection_type != "someall", na.rm=TRUE) %>%
  filter(selection_type != "allall", na.rm=TRUE) %>%
  filter(selection_type != "allallall", na.rm=TRUE)%>%
  filter(age <= 6.5)%>%
  mutate(age_round = round(age, digits = 2))%>%
  mutate(agesplit = cut(age_round, breaks=c(3, 3.5, 4, 4.5, 5, 6.5)),
         agesplit = factor(agesplit,
                           labels=c("3-3.5 years", "3.5-4 years", 
                                    "4-4.5 years", "4.5-5 years", 
                                    "5+ years")))


#for means
df$correct %<>%
  str_replace("Y", 1)%>%
  str_replace("N", 0)

df %<>%
  mutate(correct = as.numeric(correct))

```

## RT exclusions

Histogram of rts
```{r}
quartz()
qplot(rt, data = df)
```

There are *crazy* RTs. NA out everything beyond 30s and replot.

```{r}
df$clean.rt <- df$rt
df$clean.rt[df$rt > 15000] <- NA
mlog <- mean(log(df$clean.rt), na.rm=TRUE)
sdlog <- sd(log(df$clean.rt), na.rm=TRUE)

qplot(clean.rt, data=df)

qplot(log(clean.rt), 
      fill = log(clean.rt) > mlog + 3*sdlog | log(clean.rt) < mlog - 3*sdlog,
      data = df)

df$clean.rt[log(df$clean.rt) > mlog + 3*sdlog | 
              log(df$clean.rt) < mlog - 3*sdlog] <- NA
#filter df to exclude NAs (RT cleaned)
df %<>%
  filter(clean.rt != "NA")
```

# Descriptives

How many children are in each age bin?

```{r}
df %>%
  dplyr::select(sub_id, agesplit) %>%
  dplyr::distinct() %>%
  dplyr::group_by(agesplit)%>%
  dplyr::summarize(n=n())%>%
  dplyr::mutate(total.n = sum(n))
```

Age group summary stats
```{r}
df %>%
  dplyr::group_by(agesplit)%>%
  dplyr::summarise(mean = mean(age), median = median(age), sd = sd(age))
```
# Overall analysis: Performance by age

Mean performance with 95% confidence intervals over all trial types

```{r}
ms <- df %>%
  group_by(trial_type, agesplit)%>%
  multi_boot_standard("correct", na.rm=TRUE)

ms$trial_type %<>%
  str_replace("all", "All")%>%
  str_replace("none", "None")%>%
  str_replace("some", "Some")

quartz()
ggplot(data = ms, 
       aes(x=trial_type, y=mean, fill= agesplit)) +
  geom_bar(stat="identity", position = position_dodge()) +
  geom_linerange(aes(ymin = ci_lower,
                      ymax = ci_upper),
                  size = .8,
                  show.legend = FALSE,
                 position=position_dodge(.9)) +
  ylab("Proportion correct") + 
  xlab("Trial Type") +
  theme_bw(base_size = 13) + theme(axis.title.x = element_text(size=18),
           axis.title.y  = element_text(size=15)) + 
  scale_fill_solarized(name = "Age")

  # scale_fill_manual(values = c("#4EB3D3", "#2B8CBE", "#0868AC", "#084081"),
                    # name="Age")
```

Proportion correct by sub_id (initial analysis)

```{r}
ms <- df %>%
  group_by(trial_type, sub_id) %>%
  multi_boot_standard("correct", na.rm=TRUE)

ggplot(data = ms, 
       aes(x=trial_type, y=mean)) +
  geom_bar(stat="identity", position = "dodge") + ylab("Average correct") + xlab("Trial type") + facet_wrap(~sub_id)
```

Histogram of correct response for trial types.

```{r}
ms <- df %>%
  group_by(sub_id, trial_type) %>%
  summarise(correct = sum(correct))
  
ggplot(ms, aes(x = correct)) + 
  geom_histogram(binwidth = 1) +
  facet_wrap(~trial_type)
```

Dip tests. In previous versions of this task (Horowitz & Frank, 2014; Horowitz et al., in prep.), we observed a strongly correlated pattern of performance between the quantifiers "some" and "none." Are we still observing this with the iPad study?

```{r}
diptest::dip.test(filter(ms, trial_type == "all")$correct)
diptest::dip.test(filter(ms, trial_type == "some")$correct)
diptest::dip.test(filter(ms, trial_type == "none")$correct)
```

Statistical models. Note, check whether model converges with the random effect of trial type included. 

```{r}
summary(glmer(correct ~ age * trial_type + 
               (trial_type | sub_id), 
             family = "binomial", data = df))
```

# Response time analyses

Do children take longer to respond when they get trials correct?

```{r}
df %>%
  gather(measure, rt, rt, clean.rt) %>%
  group_by(trial_type, measure) %>%
  summarise(mean = mean(rt, na.rm=TRUE), 
            sd = sd(rt, na.rm=TRUE), 
            max = max(rt, na.rm=TRUE), 
            min = min(rt, na.rm=TRUE), 
            median=median(rt, na.rm=TRUE)) 
```

Visual distributions of RTs for each quantifier type

```{r}
ms <- df %>%
  group_by(agesplit, trial_type) %>%
  summarise(m = mean(clean.rt, na.rm=TRUE))

df$trial_type %<>%
  str_replace("all", "All")%>%
  str_replace("some", "Some")%>%
  str_replace("none", "None")

quartz()
ggplot(df, aes(x = clean.rt)) + 
  geom_histogram() + 
  facet_grid(agesplit ~ trial_type) + ylab("Count") + 
  xlab("Reaction Time (ms)")
  geom_vline(data = ms, aes(xintercept = m), col = "red", lty = 2)
```

What about over the course of the study? Kids may be getting faster as they go through the task.

```{r}
ggplot(df, aes(x = trial_num, y = clean.rt)) + 
  geom_point() + 
  geom_smooth(method = "lm", formula = y ~ log(x)) + 
  facet_grid(agesplit ~ trial_type)
```

Now model all of this. Add a log trial num effect to factor out variability due to the part of the experiment you're in. 

```{r}
summary(lmer(log(clean.rt) ~ scale(age, scale=FALSE) * log(trial_num) + 
               scale(age, scale=FALSE) * trial_type + 
               (trial_type | sub_id), 
             data = df))
```

# Individual differences

RT to RT correlations. 

```{r}
ms.rt <- df %>%
  group_by(trial_type, agesplit, sub_id) %>%
  summarise(rt = mean(clean.rt, na.rm=TRUE)) %>%
  spread(trial_type, rt) 

ggcorplot(ms.rt %>% filter(complete.cases(ms.rt)) %>% dplyr::select(None, Some, All))
```

Accuracy to accuracy correlations. 

```{r}
ms.acc <- df %>%
  group_by(trial_type, agesplit, sub_id) %>%
  summarise(correct = mean(correct, na.rm=TRUE)) %>%
  spread(trial_type, correct)
ggcorplot(ms.acc %>% filter(complete.cases(ms.acc)) %>% dplyr::select(None, Some, All))
```

Are there correlations between RT and getting the trial right?

```{r}
ms <- bind_rows(ms.rt %>%
                   gather(trial_type, measure, None, Some, All) %>%
                   mutate(trial_type = stringr::str_c("rt.", trial_type)), 
                 ms.acc %>%
                   gather(trial_type, measure, None, Some, All) %>%
                   mutate(trial_type = stringr::str_c("acc.", trial_type))) %>%
  spread(trial_type, measure)
  
ggcorplot(ms %>% filter(complete.cases(ms)) %>%
            dplyr::select(rt.None, rt.Some, rt.All, 
                               acc.None, acc.Some, acc.All))
```

# Selections on incorrect trials

```{r}
wrong <- df %>%
  filter(correct == "0", selection_type != "someall")%>%
  group_by(trial_type, selection_type)%>%
  dplyr::summarise(n=n())%>%
  mutate(n.total = sum(n), prop = n/n.total)

# quartz()
ggplot(data = wrong, 
       aes(x=selection_type, y=n)) +
  geom_bar(stat="identity", position = position_dodge())  +
  ylab("Count of children choosing") + 
  xlab("Selection Type") + facet_wrap(~trial_type) + theme_bw(base_size=17) + 
  theme(axis.title.x = element_text(size=18),
        axis.title.y = element_text(size=18)) + facet_wrap(~trial_type)
```


#Diffusion modeling
```{r}
trialtypes <- c("all", "some", "none")
```

#Density plots
```{r}
# df %<>%
#   mutate(q = clean.rt/(1000))

quartz()
ggplot(df, aes(x=q)) + 
  geom_density(aes(fill=resp), alpha=0.3) +
  facet_grid(agesplit ~ trial_type, scales = "free") + 
  scale_fill_solarized(name = "Response", labels=c("Correct", "Incorrect"))+
#   scale_fill_hue(labels = c("Correct", "Incorrect")) +
#   scale_color_hue(labels = c("Correct", "Incorrect")) +
  xlab("Response time (s)") + ylab("Density of responses")
```

Estimate parameters
```{r}
sub.pars <- data.frame(Separation = numeric(),
                       Non.Decision = numeric(),
                       Bias = numeric(),
                       Drift = numeric(),
                       Trial.Type = character(),
                       SubID = character(), 
                       Age = character())
sub.pars$Trial.Type <- as.character(sub.pars$Trial.Type)
sub.pars$SubID <- as.character(sub.pars$SubID)
sub.pars$Age <- as.character(sub.pars$Age)

temp.pars <- sub.pars

df$resp <- as.character(df$resp)
```

```{r}
subs <- unique(df$sub_id)

for (j in 1:length(subs)) {
  sid <- as.character(subs[j]) 
  for (i in 1:length(trialtypes)) {
    ttype <- as.character(trialtypes[i])
    dat <- as.data.frame(subset(df, trial_type == ttype & sub_id == sid))
    opt <- optim(c(1, .1, .1, 1), wiener_deviance, 
                 dat=dplyr::select(dat, c(q, resp)), method="Nelder-Mead")
    pars <- c(opt$par, ttype, sid, dat$agesplit[1])
    temp.pars[i,] <- pars
  }
  sub.pars <- rbind(temp.pars, sub.pars)
}  
```

Parameter plot
```{r}
# sub.pars <- sub.pars %>%
#   mutate(Condition = ifelse(Trial.Type == "control" | Trial.Type == "positive" | Trial.Type == "unambiguous", "Control", "Target"),
#          Game = ifelse(Trial.Type == "control" | Trial.Type == "inhib", "inhib.game", ifelse(Trial.Type == "positive" | Trial.Type == "negative", "neg.game", "imp.game")))

sub.pars$Separation <- as.numeric(sub.pars$Separation)
sub.pars$Non.Decision <- as.numeric(sub.pars$Non.Decision)
sub.pars$Bias <- as.numeric(sub.pars$Bias)
sub.pars$Drift <- as.numeric(sub.pars$Drift)

sub.pars.ms <- sub.pars %>%
  gather(Param, Value, Separation:Drift) %>%
  group_by(Age, Trial.Type, Param) %>%
  multi_boot_standard("Value", na.rm = TRUE)
# sub.pars.ms$Game <- factor(sub.pars.ms$Game, levels = c("inhib.game", "imp.game", "neg.game"))
# sub.pars.ms$AgeModality <- paste(sub.pars.ms$Age, sub.pars.ms$Modality, sep = "_")

qplot(data = subset(sub.pars.ms), x = Trial.Type, color = Trial.Type,
      y = mean, ymax=ci_upper, ymin=ci_lower, 
      geom = "pointrange", position = position_dodge(.1)) +
  facet_grid(Param~Age, scales = "free") +
  theme_bw()
```

Another parameter plot
```{r}
quartz()
qplot(data = filter(sub.pars.ms), x = Age, color = Trial.Type,
      y = mean, ymax=ci_upper, ymin=ci_lower, 
      geom = "pointrange", position = position_dodge(.25)) +
  facet_wrap(~Param , scales = "free") +
  theme_bw()
```


So I don't have to change a bunch of code when I'm not sure if it will work
```{r}
names(sub.pars.ms) = c("Age", "Trial.Type", "Param", "M", "cil", "cih")
```

Visualization
```{r}
#Visualize diffusion process for each trial_type
trialtypes <- c("all", "some", "none")
ages <- unique(sub.pars.ms$Age)
p <- list()

x <- 15 #this is max time
y <- 13 #max separation

for (a in 1:length(ages)) {
  for (g in 1:length(trialtypes)) {
    params <- sub.pars.ms %>%
      subset(Trial.Type == trialtypes[g] & Age == ages[a]) %>%
      gather(Name, Value, M:cih) %>% #because my df is in a different order from ann's
      unite(Stats, Param, Name) %>%
      spread(Stats, Value)
    params$yint_M = (params$Bias_M*params$Separation_M) - (params$Drift_M*params$Non.Decision_M)
    params$yint_cih = (params$Bias_M*params$Separation_M) - (params$Drift_cih*params$Non.Decision_M)
    params$yint_cil = (params$Bias_M*params$Separation_M) - (params$Drift_cil*params$Non.Decision_M)
    
    drift_ribbon <- data.frame(xvals = c(params$Non.Decision_M, #non-decision time
                                         (params$Separation_M - params$yint_cih) / params$Drift_cih, #Point where high drift line hits separation boundary
                                         (params$Separation_M - params$yint_M) / params$Drift_M, #Point where drift line hits separation boundary
                                         ifelse(params$Drift_cil > 0, (params$Separation_M - params$yint_cil) / params$Drift_cil, (0 - params$yint_cil) / params$Drift_cil)), #Point where low drift line hits separation boundary or 0
                               ymin = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Drift_cil*((params$Separation_M - params$yint_cih) / params$Drift_cih) + params$yint_cil, #point where low drift is when high drift ends
                                        params$Drift_cil*((params$Separation_M - params$yint_M) / params$Drift_M) + params$yint_cil, #point where low drift is when drift ends
                                        ifelse(params$Drift_cil > 0, params$Separation_M, 0)), #point where low drift ends
                               ymax = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Separation_M, #point where drift ends
                                         params$Separation_M, #point where drift ends
                                        params$Separation_M),#point where drift ends
                               Trial.Type = rep(params$Trial.Type, 4))
    
    nd_ribbon <- data.frame(xmin = params$Non.Decision_cil,
                            xmax = params$Non.Decision_cih,
                            ymin = rep(params$Bias_cil*params$Separation_cil, 2), 
                            ymax = rep(params$Bias_cih*params$Separation_cih, 2),
                            Trial.Type = params$Trial.Type)
    
    sep_ribbon <- data.frame(xmin = rep(c(0), 3),
                             xmax = rep(x, 3),
                             ymin = params$Separation_cil,
                             ymax = params$Separation_cih,
                             Trial.Type = params$Trial.Type)
    
    d.diff <- data.frame()
    
    if(params$Drift_M > 0){
      params$pxend <- (params$Separation_M - params$yint_M)/params$Drift_M
      params$pyend <- params$Separation_M
    } else{
      params$pxend <- (-(params$yint_M)/params$Drift_M)
      params$pyend <- 0
    }
    
    
    p[[g + length(trialtypes)*(a-1)]] <- ggplot(d.diff) + coord_cartesian(xlim = c(0, x), ylim = c(0, y)) + 
      geom_point() +  theme_bw() +
      geom_segment(data = params, 
                  aes(x = Non.Decision_M, 
                       # xend = (Separation_M - yint_M) / Drift_M,
                       xend = pxend,
                       y = Bias_M * Separation_M, yend = pyend,
                       color = Trial.Type)) + 
      geom_rect(data = nd_ribbon,
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_ribbon(data = drift_ribbon, 
                  aes(x = xvals, 
                      ymin = ymin, 
                      ymax = ymax,
                      fill = Trial.Type), 
                  alpha=0.2) +
      geom_rect(data = sep_ribbon, 
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_hline(data = params, 
                 aes(yintercept = Separation_M, color = Trial.Type),
                 linetype = "dashed") + 
      geom_hline(yintercept = 0, linetype = "dashed") + 
      geom_vline(data = params, 
                 aes(xintercept = Non.Decision_M, color = Trial.Type)) + 
      scale_fill_discrete(guide = FALSE) +
      scale_color_discrete(guide = FALSE) +
     xlab("Time (seconds)") + ylab("Boundary Separation") 
    ggtitle(paste(ages[a], "\n", trialtypes[g], sep = " ")) 
  } 
}

plotlist <- c(list(p[[1]], p[[2]], p[[3]], p[[4]], p[[5]], 
                   p[[6]], p[[7]], p[[8]], p[[9]], p[[10]],
                   p[[11]], p[[12]], p[[13]], p[[14]], p[[15]]), ncol = 5, nrow = 3)
do.call(grid.arrange, plotlist)
```

Looking at 3-3.5s
```{r}
p <- list()
x <- 15 #this is max time
y <- 13 #max separation

  for (g in 1:length(trialtypes)) {
    params <- sub.pars.ms %>%
      subset(Trial.Type == trialtypes[g] & Age == 1) %>%
      gather(Name, Value, M:cih) %>% #because my df is in a different order from ann's
      unite(Stats, Param, Name) %>%
      spread(Stats, Value)
    params$yint_M = (params$Bias_M*params$Separation_M) - (params$Drift_M*params$Non.Decision_M)
    params$yint_cih = (params$Bias_M*params$Separation_M) - (params$Drift_cih*params$Non.Decision_M)
    params$yint_cil = (params$Bias_M*params$Separation_M) - (params$Drift_cil*params$Non.Decision_M)
    
    drift_ribbon <- data.frame(xvals = c(params$Non.Decision_M, #non-decision time
                                         (params$Separation_M - params$yint_cih) / params$Drift_cih, #Point where high drift line hits separation boundary
                                         (params$Separation_M - params$yint_M) / params$Drift_M, #Point where drift line hits separation boundary
                                         ifelse(params$Drift_cil > 0, (params$Separation_M - params$yint_cil) / params$Drift_cil, (0 - params$yint_cil) / params$Drift_cil)), #Point where low drift line hits separation boundary or 0
                               ymin = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Drift_cil*((params$Separation_M - params$yint_cih) / params$Drift_cih) + params$yint_cil, #point where low drift is when high drift ends
                                        params$Drift_cil*((params$Separation_M - params$yint_M) / params$Drift_M) + params$yint_cil, #point where low drift is when drift ends
                                        ifelse(params$Drift_cil > 0, params$Separation_M, 0)), #point where low drift ends
                               ymax = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Separation_M, #point where drift ends
                                         params$Separation_M, #point where drift ends
                                        params$Separation_M),#point where drift ends
                               Trial.Type = rep(params$Trial.Type, 4))
    
    nd_ribbon <- data.frame(xmin = params$Non.Decision_cil,
                            xmax = params$Non.Decision_cih,
                            ymin = rep(params$Bias_cil*params$Separation_cil, 2), 
                            ymax = rep(params$Bias_cih*params$Separation_cih, 2),
                            Trial.Type = params$Trial.Type)
    
    sep_ribbon <- data.frame(xmin = rep(c(0), 3),
                             xmax = rep(x, 3),
                             ymin = params$Separation_cil,
                             ymax = params$Separation_cih,
                             Trial.Type = params$Trial.Type)
    
    d.diff <- data.frame()
    
    if(params$Drift_M > 0){
      params$pxend <- (params$Separation_M - params$yint_M)/params$Drift_M
      params$pyend <- params$Separation_M
    } else{
      params$pxend <- (-(params$yint_M)/params$Drift_M)
      params$pyend <- 0
    }
    
    
    quartz()
    p[[g]] <- ggplot(d.diff) + coord_cartesian(xlim = c(0, x), ylim = c(0, y)) + 
      geom_point() +  theme_bw() +
      geom_segment(data = params, 
                  aes(x = Non.Decision_M, 
                       # xend = (Separation_M - yint_M) / Drift_M,
                       xend = pxend,
                       y = Bias_M * Separation_M, yend = pyend,
                       color = Trial.Type)) + 
      geom_rect(data = nd_ribbon,
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_ribbon(data = drift_ribbon, 
                  aes(x = xvals, 
                      ymin = ymin, 
                      ymax = ymax,
                      fill = Trial.Type), 
                  alpha=0.2) +
      geom_rect(data = sep_ribbon, 
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_hline(data = params, 
                 aes(yintercept = Separation_M, color = Trial.Type),
                 linetype = "dashed") + 
      geom_hline(yintercept = 0, linetype = "dashed") + 
      geom_vline(data = params, 
                 aes(xintercept = Non.Decision_M, color = Trial.Type)) + 
      scale_fill_discrete(guide = FALSE) +
      scale_color_discrete(guide = FALSE) +
     xlab("Time (seconds)") + ylab("Boundary Separation") + labs(title = "3-3.5 years", "\n", trialtypes[g], sep = " ") 
} 

plotlist <- c(list(p[[1]], p[[2]], p[[3]], ncol = 3))

do.call(grid.arrange, plotlist)
```

3.5-4s
```{r}
p <- list()
x <- 15 #this is max time
y <- 13 #max separation

  for (g in 1:length(trialtypes)) {
    params <- sub.pars.ms %>%
      subset(Trial.Type == trialtypes[g] & Age == 2) %>%
      gather(Name, Value, M:cih) %>% #because my df is in a different order from ann's
      unite(Stats, Param, Name) %>%
      spread(Stats, Value)
    params$yint_M = (params$Bias_M*params$Separation_M) - (params$Drift_M*params$Non.Decision_M)
    params$yint_cih = (params$Bias_M*params$Separation_M) - (params$Drift_cih*params$Non.Decision_M)
    params$yint_cil = (params$Bias_M*params$Separation_M) - (params$Drift_cil*params$Non.Decision_M)
    
    drift_ribbon <- data.frame(xvals = c(params$Non.Decision_M, #non-decision time
                                         (params$Separation_M - params$yint_cih) / params$Drift_cih, #Point where high drift line hits separation boundary
                                         (params$Separation_M - params$yint_M) / params$Drift_M, #Point where drift line hits separation boundary
                                         ifelse(params$Drift_cil > 0, (params$Separation_M - params$yint_cil) / params$Drift_cil, (0 - params$yint_cil) / params$Drift_cil)), #Point where low drift line hits separation boundary or 0
                               ymin = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Drift_cil*((params$Separation_M - params$yint_cih) / params$Drift_cih) + params$yint_cil, #point where low drift is when high drift ends
                                        params$Drift_cil*((params$Separation_M - params$yint_M) / params$Drift_M) + params$yint_cil, #point where low drift is when drift ends
                                        ifelse(params$Drift_cil > 0, params$Separation_M, 0)), #point where low drift ends
                               ymax = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Separation_M, #point where drift ends
                                         params$Separation_M, #point where drift ends
                                        params$Separation_M),#point where drift ends
                               Trial.Type = rep(params$Trial.Type, 4))
    
    nd_ribbon <- data.frame(xmin = params$Non.Decision_cil,
                            xmax = params$Non.Decision_cih,
                            ymin = rep(params$Bias_cil*params$Separation_cil, 2), 
                            ymax = rep(params$Bias_cih*params$Separation_cih, 2),
                            Trial.Type = params$Trial.Type)
    
    sep_ribbon <- data.frame(xmin = rep(c(0), 3),
                             xmax = rep(x, 3),
                             ymin = params$Separation_cil,
                             ymax = params$Separation_cih,
                             Trial.Type = params$Trial.Type)
    
    d.diff <- data.frame()
    
    if(params$Drift_M > 0){
      params$pxend <- (params$Separation_M - params$yint_M)/params$Drift_M
      params$pyend <- params$Separation_M
    } else{
      params$pxend <- (-(params$yint_M)/params$Drift_M)
      params$pyend <- 0
    }
    
    
    quartz()
    p[[g]] <- ggplot(d.diff) + coord_cartesian(xlim = c(0, x), ylim = c(0, y)) + 
      geom_point() +  theme_bw() +
      geom_segment(data = params, 
                  aes(x = Non.Decision_M, 
                       # xend = (Separation_M - yint_M) / Drift_M,
                       xend = pxend,
                       y = Bias_M * Separation_M, yend = pyend,
                       color = Trial.Type)) + 
      geom_rect(data = nd_ribbon,
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_ribbon(data = drift_ribbon, 
                  aes(x = xvals, 
                      ymin = ymin, 
                      ymax = ymax,
                      fill = Trial.Type), 
                  alpha=0.2) +
      geom_rect(data = sep_ribbon, 
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_hline(data = params, 
                 aes(yintercept = Separation_M, color = Trial.Type),
                 linetype = "dashed") + 
      geom_hline(yintercept = 0, linetype = "dashed") + 
      geom_vline(data = params, 
                 aes(xintercept = Non.Decision_M, color = Trial.Type)) + 
      scale_fill_discrete(guide = FALSE) +
      scale_color_discrete(guide = FALSE) +
     xlab("Time (seconds)") + ylab("Boundary Separation") + labs(title = "3.5-4 years", "\n", trialtypes[g], sep = " ") 
} 

plotlist <- c(list(p[[1]], p[[2]], p[[3]], ncol = 3))

do.call(grid.arrange, plotlist)
```

4-4.5s
```{r}
p <- list()
x <- 15 #this is max time
y <- 13 #max separation

  for (g in 1:length(trialtypes)) {
    params <- sub.pars.ms %>%
      subset(Trial.Type == trialtypes[g] & Age == 3) %>%
      gather(Name, Value, M:cih) %>% #because my df is in a different order from ann's
      unite(Stats, Param, Name) %>%
      spread(Stats, Value)
    params$yint_M = (params$Bias_M*params$Separation_M) - (params$Drift_M*params$Non.Decision_M)
    params$yint_cih = (params$Bias_M*params$Separation_M) - (params$Drift_cih*params$Non.Decision_M)
    params$yint_cil = (params$Bias_M*params$Separation_M) - (params$Drift_cil*params$Non.Decision_M)
    
    drift_ribbon <- data.frame(xvals = c(params$Non.Decision_M, #non-decision time
                                         (params$Separation_M - params$yint_cih) / params$Drift_cih, #Point where high drift line hits separation boundary
                                         (params$Separation_M - params$yint_M) / params$Drift_M, #Point where drift line hits separation boundary
                                         ifelse(params$Drift_cil > 0, (params$Separation_M - params$yint_cil) / params$Drift_cil, (0 - params$yint_cil) / params$Drift_cil)), #Point where low drift line hits separation boundary or 0
                               ymin = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Drift_cil*((params$Separation_M - params$yint_cih) / params$Drift_cih) + params$yint_cil, #point where low drift is when high drift ends
                                        params$Drift_cil*((params$Separation_M - params$yint_M) / params$Drift_M) + params$yint_cil, #point where low drift is when drift ends
                                        ifelse(params$Drift_cil > 0, params$Separation_M, 0)), #point where low drift ends
                               ymax = c(params$Bias_M * params$Separation_M, #point where drift starts
                                        params$Separation_M, #point where drift ends
                                         params$Separation_M, #point where drift ends
                                        params$Separation_M),#point where drift ends
                               Trial.Type = rep(params$Trial.Type, 4))
    
    nd_ribbon <- data.frame(xmin = params$Non.Decision_cil,
                            xmax = params$Non.Decision_cih,
                            ymin = rep(params$Bias_cil*params$Separation_cil, 2), 
                            ymax = rep(params$Bias_cih*params$Separation_cih, 2),
                            Trial.Type = params$Trial.Type)
    
    sep_ribbon <- data.frame(xmin = rep(c(0), 3),
                             xmax = rep(x, 3),
                             ymin = params$Separation_cil,
                             ymax = params$Separation_cih,
                             Trial.Type = params$Trial.Type)
    
    d.diff <- data.frame()
    
    if(params$Drift_M > 0){
      params$pxend <- (params$Separation_M - params$yint_M)/params$Drift_M
      params$pyend <- params$Separation_M
    } else{
      params$pxend <- (-(params$yint_M)/params$Drift_M)
      params$pyend <- 0
    }
    
    
    quartz()
    p[[g]] <- ggplot(d.diff) + coord_cartesian(xlim = c(0, x), ylim = c(0, y)) + 
      geom_point() +  theme_bw() +
      geom_segment(data = params, 
                  aes(x = Non.Decision_M, 
                       # xend = (Separation_M - yint_M) / Drift_M,
                       xend = pxend,
                       y = Bias_M * Separation_M, yend = pyend,
                       color = Trial.Type)) + 
      geom_rect(data = nd_ribbon,
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_ribbon(data = drift_ribbon, 
                  aes(x = xvals, 
                      ymin = ymin, 
                      ymax = ymax,
                      fill = Trial.Type), 
                  alpha=0.2) +
      geom_rect(data = sep_ribbon, 
                aes(xmin = xmin,
                    xmax = xmax,
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Trial.Type), 
                alpha=0.2) +
      geom_hline(data = params, 
                 aes(yintercept = Separation_M, color = Trial.Type),
                 linetype = "dashed") + 
      geom_hline(yintercept = 0, linetype = "dashed") + 
      geom_vline(data = params, 
                 aes(xintercept = Non.Decision_M, color = Trial.Type)) + 
      scale_fill_discrete(guide = FALSE) +
      scale_color_discrete(guide = FALSE) +
     xlab("Time (seconds)") + ylab("Boundary Separation") + labs(title = "4-4.5s years", "\n", trialtypes[g], sep = " ") 
} 

plotlist <- c(list(p[[1]], p[[2]], p[[3]], ncol = 3))

do.call(grid.arrange, plotlist)
```


Looking at individual age groups
```{r}
params <- sub.pars.ms %>%
    subset(Trial.Type == "all" & Age == "1") %>%
    gather(Name, Value, M:cil, cih) %>%
    unite(Stats, Param, Name) %>%
    spread(Stats, Value)
  params$yint_M = (params$Bias_M*params$Separation_M) - (params$Drift_M*params$Non.Decision_M)
  params$yint_cih = (params$Bias_M*params$Separation_M) - (params$Drift_cih*params$Non.Decision_M)
  params$yint_cil = (params$Bias_M*params$Separation_M) - (params$Drift_cil*params$Non.Decision_M)
  
  drift_ribbon <- data.frame(xvals = c(params$Non.Decision_M, #non-decision time
                                       (params$Separation_M - params$yint_cih) / params$Drift_cih, #Point where high drift line hits separation boundary
                                       (params$Separation_M - params$yint_cil) / params$Drift_cil), #Point where low drift line hits separation boundary
                             ymin = c(params$Bias_M * params$Separation_M, #point where drift starts
                                      params$Drift_cil*((params$Separation_M - params$yint_cih) / params$Drift_cih) + params$yint_cil, #point where low drift is when high drift ends
                                      params$Separation_M), #point where low drift ends
                             ymax = c(params$Bias_M * params$Separation_M, #point where drift starts
                                      params$Separation_M, #point where drift ends
                                      params$Separation_M),#point where drift ends
                             Trial.Type = rep(params$Trial.Type, 3))
  
  nd_ribbon <- data.frame(xmin = params$Non.Decision_cil,
                          xmax = params$Non.Decision_cih,
                          ymin = rep(params$Bias_cil*params$Separation_cil, 2), 
                          ymax = rep(params$Bias_cih*params$Separation_cih, 2),
                          Condition = params$Condition)
  
  sep_ribbon <- data.frame(xmin = rep(c(0), 2),
                           xmax = rep(x, 2),
                           ymin = params$Separation_cil,
                           ymax = params$Separation_cih,
                           Condition = params$Condition)
  
  df <- data.frame()
  
  p[[g]] <- ggplot(df) + ylim(c(0, y)) + xlim(c(0, x)) +
    geom_point() +  theme_bw() +
    geom_segment(data = params, 
                 aes(x = Non.Decision_M, 
                     xend = (Separation_M - yint_M) / Drift_M,
                     y = Bias_M * Separation_M, yend = Separation_M, 
                     color = Condition)) + 
    geom_rect(data = nd_ribbon,
              aes(xmin = xmin,
                  xmax = xmax,
                  ymin = ymin, 
                  ymax = ymax,
                  fill = Condition), 
              alpha=0.2) +
    geom_ribbon(data = drift_ribbon, 
                aes(x = xvals, 
                    ymin = ymin, 
                    ymax = ymax,
                    fill = Condition), 
                alpha=0.2) +
    geom_rect(data = sep_ribbon, 
              aes(xmin = xmin,
                  xmax = xmax,
                  ymin = ymin, 
                  ymax = ymax,
                  fill = Condition), 
              alpha=0.2) +
    geom_hline(data = params, 
               aes(yintercept = Separation_M, color = Condition),
               linetype = "dashed") + 
    geom_hline(yintercept = 0, linetype = "dashed") + 
    geom_vline(data = params, 
               aes(xintercept = Non.Decision_M, color = Condition)) + 
    #theme(legend.position=c(.9, .8)) +
    xlab("Time (seconds)") + ylab("Boundary Separation") #+ #ggtitle(paste("adults", games[g], sep = " ")) 
 


print(p)
```
Planned analyses: 
1. Developmental differences in accuracy (replication of previous work)
2. RTs in general for correct/incorrect choices
3. Diffusion model analysis: RT as a measure of processing time

# Diffusion models

Weiner plot

```{r}
wiener.plot <- function (dat) 
{
  rt = as.double(dat$q)
  rc = as.numeric(as.factor(dat$resp))
  dpos = tryCatch(density(rt[rc == 1], from = 0),error=function(e) NA)
  dneg = tryCatch(density(rt[rc == 2], from = 0),error=function(e) NA)
  maxt = max(pretty(max(rt)))
  
  maxd <- NA
  if(is.na(dpos[1])){
    maxd <- max(dneg$y)
  } else if(is.na(dneg[1])){
    maxd <- max(dpos$y)
  } else {
    maxd <- max(dpos$y, dneg$y)
  }
  
  par(mar = c(0, 5, 0, 0), mfcol = c(2, 1), ask = FALSE)
  plot(dpos, xlim = c(0, maxt), ylim = c(0, maxd), las = 2, 
       lwd = 2, col = "green3", main = "", ylab = "", ask = FALSE)
  rug(rt[rc == 1], col = "green3")
  mtext("Density of positive responses", side = 2, line = 4, 
        cex = 0.8)
  plot(dneg, xlim = c(0, maxt), ylim = c(maxd, 0), las = 2, 
       lwd = 2, col = "red", main = "", ylab = "", ask = FALSE)
  mtext("Density of negative responses", side = 2, line = 4, 
        cex = 0.8)
  rug(rt[rc == 2], col = "red", side = 3)
}
```


# Old code


This is an option for removing plus and minus one sd - not effective right now, as data is sparse
```{r}
# hist_all <- df %>%
#   filter(trial_type == "all")
# 
# df.all <- df.rt %>%
#   filter(trial_type == "all")
# 
# df.some <- df.rt %>%
#   filter(trial_type == "some")
# 
# df.none <- df.rt %>%
#   filter(trial_type == "none")
# 
# ms.all <- df %>%
#   mutate(half = cut(trial_num, breaks=c(0, 15, 30)),
#           half = factor(half,
#                             labels=c("First", "Second")))%>%
#   mutate(correct = as.factor(correct))%>%
#   group_by(trial_type, agesplit, correct)%>%
#   filter(trial_type == "all")%>%
#   filter(rt >= df.all$lower | rt <= df.all$upper)
# 
# ms.some <- df %>%
#   mutate(half = cut(trial_num, breaks=c(0, 15, 30)),
#           half = factor(half,
#                             labels=c("First", "Second")))%>%
#   mutate(correct = as.factor(correct))%>%
#   group_by(trial_type, agesplit, correct)%>%
#   filter(trial_type == "some")%>%
#   filter(rt >= df.some$lower | rt <= df.some$upper)
# 
# ms.none <- df %>%
#   mutate(half = cut(trial_num, breaks=c(0, 15, 30)),
#           half = factor(half,
#                             labels=c("First", "Second")))%>%
#   mutate(correct = as.factor(correct))%>%
#   group_by(trial_type, agesplit, correct)%>%
#   filter(trial_type == "none")%>%
#   filter(rt >= df.none$lower | rt <= df.none$upper)
# 
# tmp <- rbind(ms.some, ms.all)
# 
# #final dataframe with cleaned rts
# ms.rt <- rbind(ms.none, tmp)
```

RT analysis with plus and minus one sd removed
```{r}
# df %<>%
#   mutate(correct = as.factor(correct))
# 
# mss <- ms.rt %>%
#   group_by(trial_type, correct, agesplit)%>%
#   multi_boot_standard("rt", na.rm=T)
# 
# ggplot(data = mss, 
#        aes(x=trial_type, y=mean, fill=correct)) +
#   geom_bar(stat="identity", position = "dodge") +
#   geom_linerange(aes(ymin = ci_lower,
#                       ymax = ci_upper),
#                   size = .8,
#                   show_guide = FALSE,
#                  position=position_dodge(1)) +
#   ylab("Mean RT (ms)") + 
#   xlab("Trial Type") + facet_wrap(~agesplit)
```


This is an option with log-transformed values, and filtering plus/minus 2sd
```{r}
df %<>%
  mutate(correct_factor = as.factor(correct))

mss <- df %>%
  group_by(trial_type, correct_factor, agesplit)%>%
  multi_boot_standard("rt", na.rm = T)
```

RT analysis with log-transformed values
```{r}
quartz()
ggplot(data = mss, 
       aes(x=trial_type, y=mean, fill=correct_factor)) +
  geom_bar(stat="identity", position = "dodge") +
  geom_linerange(aes(ymin = ci_lower,
                      ymax = ci_upper),
                  size = .8,
                  show.legend = FALSE,
                 position=position_dodge(1)) +
  ylab("Mean RT (ms)") + 
  xlab("Trial Type") + facet_wrap(~agesplit)
```

```{r}
library(ppcor)
#first, look at the distribution of RTs over trials
rt.dist <- df %>%
  mutate(correct = as.factor(correct))%>%
  group_by(trial_num, agesplit, correct)%>%
  multi_boot_standard("rt", na.rm = T)

#correlation between trial num and rt?
cor.test(rt.dist$trial_num, rt.dist$mean)
#visual
ggplot(data = rt.dist, 
       aes(x=trial_num, y=mean, fill=agesplit)) +
  geom_bar(stat="identity", position = "dodge") +
  geom_linerange(aes(ymin = ci_lower,
                      ymax = ci_upper),
                  size = .8,
                  show.legend = FALSE,
                 position=position_dodge(1)) + 
  ylab("Mean RT (ms)") + 
  xlab("Trial Number") + facet_grid(correct~agesplit)

#compare the distributions between the correct and incorrect rts
```


```{r}
cor.test(cs.all$rt_all, cs.all$all)
cor.test(cs.all$rt_some, cs.all$some)
cor.test(cs.all$rt_none, cs.all$none)
```

What about the correlation between some and none?
```{r}
cor.test(cs.all$some, cs.all$none)
```

Individual differences graphs
```{r}
#individual differences graph - all 
quartz()
ggplot(cs.all, aes(x=rt_all, y=all, colour=age)) + 
  geom_point(stat = "identity", position = position_jitter(.02), shape=16) +
  geom_smooth(method="lm", col="black", lty=1) + 
  geom_smooth(aes(col=age, group=age), 
				se=FALSE, method="lm",lty=3) + scale_colour_manual(values = c("#4EB3D3", "#2B8CBE", "#0868AC", "#084081")) + theme_bw(base_size=20) + theme(axis.title.y = element_text(size = 18), 
				                      axis.title.x = element_text(size = 18)) +
  labs(x = 'Mean RT(ms) for "all" trials', y = 'Proportion of "all" trials correct')

#some
quartz()
ggplot(cs.all, aes(x=rt_some, y=some, colour=age)) + 
  geom_point(stat = "identity", position = position_jitter(.02), shape=16) +
  geom_smooth(method="lm", col="black", lty=1) + 
  geom_smooth(aes(col=age, group=age), 
				se=FALSE, method="lm",lty=3) + scale_colour_manual(values = c("#4EB3D3", "#2B8CBE", "#0868AC", "#084081")) + theme_bw(base_size=20) + theme(axis.title.y = element_text(size = 18), 
				                      axis.title.x = element_text(size = 18)) +
  labs(x = 'Mean RT(ms) for "some" trials', y = 'Proportion of "some" trials correct')

#none
quartz()
ggplot(cs.all, aes(x=rt_none, y=none, colour=age)) + 
  geom_point(stat = "identity", position = position_jitter(.02), shape=16) +
  geom_smooth(method="lm", col="black", lty=1) + 
  geom_smooth(aes(col=age, group=age), 
				se=FALSE, method="lm",lty=3) + scale_colour_manual(values = c("#4EB3D3", "#2B8CBE", "#0868AC", "#084081")) + theme_bw(base_size=20) + theme(axis.title.y = element_text(size = 18), 
				                      axis.title.x = element_text(size = 18)) +
  labs(x = 'Mean RT(ms) for "none" trials', y = 'Proportion of "none" trials correct')
```

RT analysis
```{r}
# #Split by first half and second half of experiment (at least now), because they get much faster as the study goes on
# mss <- ms.rt %>%
#   group_by(trial_type, half, agesplit, correct)%>%
#   multi_boot_standard("rt", na.rm=T)
# 
# quartz()
# ggplot(data = mss, 
#        aes(x=trial_type, y=mean, fill=correct)) +
#   geom_bar(stat="identity", position = "dodge") +
#   geom_linerange(aes(ymin = ci_lower,
#                       ymax = ci_upper),
#                   size = .8,
#                   show_guide = FALSE,
#                  position=position_dodge(1)) +
#   ylab("Mean RT (ms)") + 
#   xlab("Trial Type") + scale_fill_manual(values = c("#4EB3D3", "#2B8CBE")) + facet_grid(agesplit~half)
```


